# 线性码（Linear Code）
## **线性码的背景与动机**

在前面的讨论中，我们将一个码 **C** 简单地定义为 **Bⁿ**（所有长度为 n 的二进制字符串集合）的一个**非空子集**。

但是，这样的定义**缺乏数学结构**：
- 编码/解码可能需要查表，效率低
- 难以分析码的性质
- 实现复杂

因此，我们希望给码字集合 **C** 添加一些**代数结构**，使其更易于使用和分析。这就是引入**线性码**的原因。


## **基础定义**

### **1. 字（二进制串）的加法**
设 `x` 和 `y` 是两个**长度相同**的二进制字。它们的**和** `x + y` 定义为**按位模 2 加法**。

**运算规则**：
- `0 + 0 = 0`
- `0 + 1 = 1`
- `1 + 0 = 1`
- `1 + 1 = 0` （因为模 2）

**示例**：
```
x = 1101
y = 0110

逐位相加：
位1: 1 + 0 = 1
位2: 1 + 1 = 0
位3: 0 + 1 = 1
位4: 1 + 0 = 1

结果：x + y = 1011
```

**注意**：这种加法就是**按位异或（XOR）**运算。

### **2. 线性码的定义**
一个码 **C** 称为**线性码**，如果**任意两个码字的和仍然是码字**。

**数学表述**：

$$
\forall x, y \in C, \quad x + y \in C
$$

**等价说法**：码字集合 **C** 在按位模 2 加法下是**封闭的**。


## **线性码的性质**

### **性质 1：必须包含零字**
如果 C 是线性码，那么它**一定包含**零字 `0 = 00...0`（全零字符串）。

**证明**：
取任意码字 `c ∈ C`，根据线性码定义：
- `c + c ∈ C`（因为两个码字相加得码字）
- 但 `c + c = 0`（因为每位都是 `1+1=0` 或 `0+0=0`）
- 所以 `0 ∈ C`

**重要**：这是一个**必要条件**，但不是**充分条件**。即：
- 线性码 ⇒ 包含零字 ✓
- 包含零字 ⇒ 线性码 ✗（反例见后）

### **性质 2：对加法构成群**
所有码字在模 2 加法下构成一个**阿贝尔群（交换群）**：
1. **封闭性**：码字相加得码字
2. **结合律**：`(x + y) + z = x + (y + z)`
3. **单位元**：零字 `0` 是单位元
4. **逆元**：每个码字的逆元是它自身（`c + c = 0`）
5. **交换律**：`x + y = y + x`

### **性质 3：标量乘法封闭性**
对于二进制域 GF(2) = {0, 1}，有：
- `0·c = 0`（零字）
- `1·c = c`（自身）

结合加法封闭性，线性码实际上是**向量空间**（GF(2)上的子空间）。


## **例子分析**

### **例 1：码 C₁ = {000, 011, 101, 110}**
**验证线性性**：
检查所有码字对的和是否仍在 C₁ 中：
1. `011 + 101 = 110` ∈ C₁ ✓
2. `011 + 110 = 101` ∈ C₁ ✓
3. `101 + 110 = 011` ∈ C₁ ✓
4. 每个码字与自身相加：`000` ∈ C₁ ✓
5. 每个码字与 `000` 相加：得到自身 ∈ C₁ ✓

**同时**：C₁ 包含零字 `000`。

**结论**：C₁ 是线性码。

### **例 2：码 C₂ = {000000, 010101, 101010, 111111}**
**验证**：
1. `010101 + 101010 = 111111` ∈ C₂ ✓
2. `010101 + 111111 = 101010` ∈ C₂ ✓
3. `101010 + 111111 = 010101` ∈ C₂ ✓
4. 自加得零：`000000` ∈ C₂ ✓

**结论**：C₂ 也是线性码。

### **例 3：码 C₃ = {001, 010, 100, 000}**
**验证**：
- 包含零字 `000` ✓
- 检查封闭性：
  - `001 + 010 = 011` ∉ C₃ ✗
  - `001 + 100 = 101` ∉ C₃ ✗
  - `010 + 100 = 110` ∉ C₃ ✗

**结论**：C₃ **不是**线性码，尽管它包含零字。
这验证了备注中的观点：**包含零字是线性码的必要但不充分条件**。

## **线性码的优越性**

### **1. 编码简单**
线性码可以用**生成矩阵**表示：
- 存在 k×n 的生成矩阵 G
- 信息字 `m`（k 位）编码为：`c = m·G`
- 无需存储所有码字，只需存储矩阵

### **2. 解码简单**
- 可以用**校验矩阵** H 进行校验：`c·Hᵀ = 0` 当且仅当 c 是码字
- 存在高效的**伴随式解码**算法

### **3. 距离计算简单**
对于线性码：
- **最小距离 = 最小非零码字的重量**
- 码字重量：码字中 1 的个数
- 不必比较所有码字对，只需检查非零码字的重量

**验证**：
对于 C₁，非零码字重量：
- `011`：重量 2
- `101`：重量 2
- `110`：重量 2
最小重量 = 2 = 最小距离 ✓

对于 C₂：
- `010101`：重量 3
- `101010`：重量 3
- `111111`：重量 6
最小重量 = 3 = 最小距离 ✓

### **4. 系统性编码容易实现**
任何线性码都可以转化为**系统形式**（信息位在前，校验位在后）。


## **应用意义**

在实际通信系统中：
1. **绝大多数实用的纠错码都是线性码**：汉明码、BCH码、里德-所罗门码、LDPC码等
2. **线性结构简化了硬件实现**：可以用线性反馈移位寄存器等简单电路实现
3. **便于分析性能**：可以用代数工具分析距离分布、错误概率等

**总结**：线性码通过引入代数结构，将复杂的编码理论问题转化为相对简单的线性代数问题，是纠错码理论中最重要、应用最广泛的一类码。

好的，我们来详细解释**汉明重量**及其在线性码中的重要性。

## **汉明重量**

### **最小距离的重要性**
从第1讲我们知道，码 **C** 的**最小距离**：

$$
d(C) = \min\{d(x, y) \mid x, y \in C, x \neq y\}
$$

决定了码的纠错能力：
- 如果 `d(C) ≥ s+1`，可以检测 **s** 个错误
- 如果 `d(C) ≥ 2t+1`，可以纠正 **t** 个错误


### **汉明重量的定义**

#### **1. 字的汉明重量**
对于二进制字 `x ∈ Bⁿ`，它的**汉明重量** `wt(x)` 是 **x 中 1 的个数**。

**示例**：
- `wt(000) = 0`
- `wt(011) = 2`
- `wt(101010) = 3`
- `wt(111111) = 6`

#### **2. 码的汉明重量**
对于码 **C**（不一定是线性码），它的**最小汉明重量**是：

$$
wt(C) = \min\{wt(x) \mid x \in C, x \neq 0\}
$$

即所有**非零码字**的重量中的最小值。


### **示例分析**

#### **例 1：码 C₁ = {000, 011, 101, 110}**
- 非零码字重量：`wt(011) = 2`, `wt(101) = 2`, `wt(110) = 2`
- **最小重量**：`wt(C₁) = 2`

#### **例 2：码 C₂ = {000000, 010101, 101010, 111111}**
- 非零码字重量：`wt(010101) = 3`, `wt(101010) = 3`, `wt(111111) = 6`
- **最小重量**：`wt(C₂) = 3`

#### **例 3：码 C₃ = {001, 010, 100, 000}**
- 非零码字重量：`wt(001) = 1`, `wt(010) = 1`, `wt(100) = 1`
- **最小重量**：`wt(C₃) = 1`


### **关键引理与定理**

#### **引理：距离与重量的关系**
如果 `x` 和 `y` 是相同长度的二进制字，那么：

$$
d(x, y) = wt(x + y)
$$

**证明思路**：
- `d(x, y)` 是 x 和 y 不同的位数
- `x + y`（模 2 加法）在 x 和 y 不同的位置为 1，相同的位置为 0
- 所以 `wt(x + y)` 就是 x 和 y 不同的位数

**示例验证**：
```
x = 1101, y = 0110
d(x, y) = 3（第1、3、4位不同）
x + y = 1011
wt(1011) = 3
确实 d(x, y) = wt(x + y) ✓
```

#### **定理：线性码的最小距离等于最小重量**
如果 **C** 是线性码，那么：

$$
d(C) = wt(C)
$$

**证明**：
1. 设 `d = d(C)`，`w = wt(C)`
2. **证明 d ≤ w**：
   - 取最小重量码字 `c`，使得 `wt(c) = w`
   - 由于 `c ≠ 0`，有 `d(0, c) = wt(c) = w`
   - 所以 `d = d(C) ≤ w`
3. **证明 w ≤ d**：
   - 取两个不同码字 `x, y` 使得 `d(x, y) = d`
   - 由于 C 是线性码，`x + y ∈ C` 且 `x + y ≠ 0`（因为 x ≠ y）
   - `wt(x + y) = d(x, y) = d`
   - 所以 `w = wt(C) ≤ d`
4. 综上，`d = w`

**重要推论**：对于线性码，**计算最小距离只需检查所有非零码字的重量**，而不需要比较所有码字对。


### **非线性码的反例**

#### **例：码 C = {001, 010, 100, 111}**
**验证性质**：
1. **最小距离计算**：
   - d(001, 010) = 2
   - d(001, 100) = 2
   - d(001, 111) = 2
   - d(010, 100) = 2
   - d(010, 111) = 2
   - d(100, 111) = 2
   - **d(C) = 2**

2. **最小重量计算**：
   - 非零码字重量：`wt(001) = 1`, `wt(010) = 1`, `wt(100) = 1`, `wt(111) = 3`
   - **wt(C) = 1**

3. **结论**：`d(C) = 2 ≠ 1 = wt(C)`
   - 这并不奇怪，因为 C 不是线性码
   - 验证线性性：`001 + 010 = 011 ∉ C`，所以不是线性码


### **推论：纠错能力的重量判据**

对于线性码 C：
- **(i)** 如果 `wt(C) ≥ s+1`，那么 C 是 **s-错误检测**的
- **(ii)** 如果 `wt(C) ≥ 2t+1`，那么 C 是 **t-错误纠正**的

**解释**：因为对于线性码，`wt(C) = d(C)`，所以这直接来自最小距离的纠错判据。

### **综合示例分析**

### **码 C = {000000000, 101010101, 010101010, 111111111}**
**验证**：
1. **线性性检查**：
   - `101010101 + 010101010 = 111111111` ∈ C ✓
   - `101010101 + 111111111 = 010101010` ∈ C ✓
   - `010101010 + 111111111 = 101010101` ∈ C ✓
   - 自加得零：`000000000` ∈ C ✓
   - **是线性码**

2. **重量计算**：
   - `wt(101010101)`：数 1 的个数（模式 101...），共 5 个 1？等等，我们仔细数：
     ```
     1 0 1 0 1 0 1 0 1
     位置：1,3,5,7,9 是 1 → 共 5 个 1
     wt(101010101) = 5
     ```
   - `wt(010101010)`： 4 个 1
   - `wt(111111111) = 9`
   - 所以 `wt(C) = min(5, 4, 9) = 4`

3. **纠错能力**：
   - 因为 `wt(C) = 4`，根据定理：
     - 检错：`4 ≥ s+1` ⇒ `s ≤ 3`，所以是 **3-错误检测**
     - 纠错：`4 ≥ 2t+1` ⇒ `2t+1 ≤ 4` ⇒ `t ≤ 1.5` ⇒ `t = 1`，所以是 **1-错误纠正**

### **总结表格**

| 概念 | 定义 | 对线性码的特殊性质 |
|------|------|-------------------|
| **汉明距离 d(x,y)** | x 和 y 不同的位数 | 满足度量公理 |
| **汉明重量 wt(x)** | x 中 1 的个数 | - |
| **码的最小距离 d(C)** | 不同码字对的最小距离 | `d(C) = wt(C)` |
| **码的最小重量 wt(C)** | 非零码字的最小重量 | 等于最小距离 |
| **s-错误检测** | 改变 ≤s 位不会变成其他码字 | `wt(C) ≥ s+1` |
| **t-错误纠正** | 可以唯一纠正 ≤t 个错误 | `wt(C) ≥ 2t+1` |

## **实际意义**
1. **线性码的优势**：只需计算非零码字的重量就能得到最小距离，大大简化了分析。
2. **设计指导**：要获得强纠错能力的线性码，就要设计具有**大最小重量**的码。

理解汉明重量与最小距离的关系，是分析和设计线性纠错码的基础工具。


## **生成矩阵：线性码的编码工具**

### **1. [n, k]-线性码的定义**
设 **C** 是一个长度为 **n** 的线性码。如果我们用它来编码长度为 **k** 的信息字（其中 `k < n`），那么称 **C** 为一个 **线性 [n, k]-码**。

- **n**：码字长度（编码后的长度）
- **k**：信息字长度（编码前的长度），也称为码的**维度**
- 码的大小：`|C| = 2^k`（因为有 2^k 个可能的信息字）

**示例回顾**：
- **码 C₁ = {000, 011, 101, 110}**：`n=3`, `k=2`，是 **[3,2]-码**
- **码 C₂ = {000000, 010101, 101010, 111111}**：`n=6`, `k=2`，是 **[6,2]-码**

### **生成矩阵的定义与作用**

#### **2. 编码映射的矩阵表示**
对于一个线性 **[n, k]-码**，编码映射 `E: Bᵏ → Bⁿ` 可以通过一个 **k×n 二进制矩阵 G** 来定义：

设信息字为 `x = x₁x₂...xₖ ∈ Bᵏ`，将其视为**行向量**：

$$
\mathbf{x} = (x₁, x₂, ..., xₖ)
$$

令 **G** 是一个 k×n 的二进制矩阵。通过计算：

$$
\mathbf{y} = \mathbf{x}G \quad (\text{模 2 运算})
$$

得到一个 n 维行向量 `y = (y₁, y₂, ..., yₙ)`，对应的码字就是 `y = y₁y₂...yₙ`。

**简单说**：`码字 = (信息向量) × (生成矩阵)`

### **生成矩阵的条件**

#### **3. 为什么不是任意矩阵都行？**
编码映射 `E` 必须是**单射**（一一映射）：
- 不同的信息字必须映射到不同的码字
- 即：`x₁ ≠ x₂ ⇒ E(x₁) ≠ E(x₂)`

**定理**：映射 `E(x) = xG` 是单射，当且仅当：
1. **条件 (i)**：G 的所有行**互不相同**，且没有全零行
2. **条件 (ii)**：G 的任意一行**不能**写成其他两行或多行的和

**定义**：满足条件 (i) 和 (ii) 的二进制 k×n 矩阵 G 称为线性 **[n, k]-码的生成矩阵**。

### **示例分析**

#### **例 1：合格的生成矩阵**

$$
G₁ = \begin{pmatrix}
1 & 0 & 1 & 1 & 1 \\
0 & 1 & 1 & 0 & 0 \\
1 & 0 & 1 & 1 & 0
\end{pmatrix}
$$

这是一个 **3×5 矩阵**，可以定义一个 **[5,3]-码**：
- 三行互不相同 ✓
- 没有全零行 ✓
- 检查条件 (ii)：第3行 = 第1行 + 第2行？  
  `10110` vs `10111 + 01100 = 11011`，不相等 ✓  
  （实际上：`10111 + 01100 = 11011`，不等于 `10110`）

#### **例 2：不合格的生成矩阵**

$$
G₂ = \begin{pmatrix}
1 & 0 & 1 & 0 & 1 \\
1 & 1 & 0 & 1 & 1 \\
0 & 1 & 1 & 1 & 0
\end{pmatrix}
$$

问题：**第3行 = 第1行 + 第2行**（模 2 加法）：
- 第1行：`10101`
- 第2行：`11011`
- 第1行 + 第2行 = `01110`？等等，计算：
  `10101 + 11011 = 01110`（模 2）
  但第3行是 `01110`？检查：第3行是 `01110` ✓
  所以确实第3行 = 第1行 + 第2行

因此 `E(x) = xG₂` **不是单射**。
例如：信息字 `(1,1,0)` 和 `(0,0,1)` 会映射到同一个码字：
- `(1,1,0)G₂ = 第1行 + 第2行 = 01110`
- `(0,0,1)G₂ = 第3行 = 01110`

### **生成矩阵的行是码字**

设 **eᵢ ∈ Bᵏ** 表示第 i 位为 1、其余位为 0 的字：
- `e₁ = 100...0`
- `e₂ = 010...0`
- ...
- `eₖ = 000...1`

由于对任意 `x ∈ Bᵏ`，`xG` 都是码字，特别地：
- `e₁G` = G 的第1行
- `e₂G` = G 的第2行
- ...
- `eₖG` = G 的第k行

**结论**：**生成矩阵的每一行本身就是一个码字**（对应信息字为 `eᵢ` 的编码）。

### **编码示例**

#### **例：用 G₁ 编码**

$$
G = \begin{pmatrix}
1 & 0 & 1 & 1 & 1 \\
0 & 1 & 1 & 0 & 0 \\
1 & 0 & 1 & 1 & 0
\end{pmatrix}
$$

编码信息字 `011`：
1. 信息向量：`x = (0, 1, 1)`
2. 计算：`y = xG = 0×(第1行) + 1×(第2行) + 1×(第3行)`
   - 第2行：`01100`
   - 第3行：`10110`
   - 求和：`01100 + 10110 = 11010`（模 2）
3. 码字：`11010`

**全部码字**（共 2³ = 8 个）：
- `00000` ← `000`
- `10111` ← `100`（第1行）
- `01100` ← `010`（第2行）
- `10110` ← `001`（第3行）
- `11011` ← `110` = 第1行+第2行
- `11010` ← `011` = 第2行+第3行
- `00001` ← `101` = 第1行+第3行
- `01101` ← `111` = 第1行+第2行+第3行

### **系统码的生成矩阵**

#### **系统形式**
一个 **[n, k]-码** 是**系统的**，如果对每个信息字 `x ∈ Bᵏ`，对应的码字 `E(x)` 是通过在 `x` 后面直接添加 `n-k` 个校验位形成的。

**系统码的生成矩阵形式**：
如果 G 是系统线性 [n,k]-码的生成矩阵，那么它的**前 k 列构成 k 阶单位矩阵 Iₖ**：

$$
G = [Iₖ \mid A]
$$

其中：
- `Iₖ`：k×k 单位矩阵
- `A`：k×(n-k) 的二进制矩阵

**结构**：
```
G = [信息位部分 | 校验位部分]
   = [   Iₖ      |     A     ]
```
编码时：`(x₁,...,xₖ) × G = (x₁,...,xₖ, 校验位)`

#### **示例**

$$
G = \begin{pmatrix}
1 & 0 & 0 & 1 & 0 \\
0 & 1 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1
\end{pmatrix} = [I₃ \mid A], \quad A = \begin{pmatrix} 1 & 0 \\ 1 & 1 \\ 0 & 1 \end{pmatrix}
$$

这是**系统 [5,3]-码**的生成矩阵。

编码信息字 `101`：
- `(1,0,1) × G = (1,0,1, 1×1+0×1+1×0, 1×0+0×1+1×1) = (1,0,1,1,1)`
- 码字：`10111`，前3位就是信息位 `101`


### **重要概念总结**

| 概念 | 解释 |
|------|------|
| **[n,k]-码** | 信息长 k，码字长 n 的线性码 |
| **生成矩阵 G** | k×n 矩阵，定义编码：`E(x) = xG` |
| **单射条件** | G 的行互不相同，且任意行不是其他行的和 |
| **G 的行** | 本身就是码字（对应单比特信息） |
| **系统形式** | `G = [Iₖ \mid A]`，信息位直接出现在码字中 |
| **码字总数** | 2ᵏ 个（因为 k 比特信息有 2ᵏ 种可能） |


### **实际意义**

1. **编码简化**：线性编码只需矩阵乘法，硬件易实现
2. **存储节省**：只需存储 k×n 的生成矩阵，而非所有 2ᵏ 个码字
3. **系统形式优势**：
   - 信息位直接可见
   - 部分解码时可直接提取信息
   - 编码器更简单（信息位直接复制）

4. **非系统也可转换**：任何线性码都有等价的系统形式（通过行运算和列置换）

**设计考虑**：在实际系统中，通常优先使用系统形式的生成矩阵，因为它结合了线性码的代数结构和系统码的直观性，是纠错码理论中最常用的表示方法。

好的，我来详细解释**校验矩阵**和**汉明码**这两个核心概念。


## **第一部分：校验矩阵**

### **1. 校验矩阵的定义**

**定义（校验矩阵）**
设 **G** 是线性 [n, k]-码 **C** 的生成矩阵（k×n 矩阵）。如果存在一个二进制矩阵 **H**（n×(n-k) 矩阵），使得：

$$
G H \equiv O \pmod{2}
$$

其中 O 是 k×(n-k) 的零矩阵，那么 **H** 称为码 **C** 的**校验矩阵**。

**关键点**：
- **G**：k×n（行数 = 信息长度，列数 = 码字长度）
- **H**：n×(n-k)（行数 = 码字长度，列数 = 冗余位数）

---

### **2. 示例验证**

**生成矩阵**：

$$
G = \begin{pmatrix}
1 & 0 & 1 & 1 & 1 \\
0 & 1 & 1 & 0 & 0 \\
1 & 0 & 1 & 1 & 0
\end{pmatrix}
$$

**校验矩阵**：

$$
H = \begin{pmatrix}
1 & 1 \\
0 & 1 \\
0 & 1 \\
1 & 0 \\
0 & 0
\end{pmatrix}
$$

**验证 GH = O**：
```
G(3×5) × H(5×2) = ?
逐行计算：
第1行：(1,0,1,1,1)·H = (1×1+0×0+1×0+1×1+1×0, 1×1+0×1+1×1+1×0+1×0)
                   = (1+0+0+1+0, 1+0+1+0+0) = (0, 0) mod 2 ✓

第2行：(0,1,1,0,0)·H = (0×1+1×0+1×0+0×1+0×0, 0×1+1×1+1×1+0×0+0×0)
                   = (0+0+0+0+0, 0+1+1+0+0) = (0, 0) mod 2 ✓

第3行：(1,0,1,1,0)·H = (1×1+0×0+1×0+1×1+0×0, 1×1+0×1+1×1+1×0+0×0)
                   = (1+0+0+1+0, 1+0+1+0+0) = (0, 0) mod 2 ✓
```
确实 **GH ≡ O**！


### **3. 系统码的校验矩阵构造**

**定理**：如果生成矩阵是系统形式：`G = [Iₖ | A]`，那么对应的校验矩阵为：

$$
H = \begin{bmatrix} A \\ I_{n-k} \end{bmatrix}
$$

**示例**：

$$
G = \begin{pmatrix}
1 & 0 & 0 & 1 & 0 \\
0 & 1 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1
\end{pmatrix} = [I₃ | A], \quad A = \begin{pmatrix} 1 & 0 \\ 1 & 1 \\ 0 & 1 \end{pmatrix}
$$

则：

$$
H = \begin{bmatrix} A \\ I₂ \end{bmatrix} = 
\begin{pmatrix}
1 & 0 \\
1 & 1 \\
0 & 1 \\
1 & 0 \\
0 & 1
\end{pmatrix}
$$



## **第二部分：校验矩阵的作用**

### **4. 错误检测原理**

设 **c** 是一个码字，那么：

$$
cH = (xG)H = x(GH) = xO = 0
$$

即：**任何合法码字与校验矩阵相乘都得到零向量**。

如果传输中发生错误，收到 `y = c + e`（其中 e 是错误向量）：

$$
yH = (c + e)H = cH + eH = 0 + eH = eH
$$

- 如果 `yH = 0` ⇒ y 是合法码字（可能无错，或错误模式恰好是另一个码字）
- 如果 `yH ≠ 0` ⇒ y 一定不是合法码字（检测到错误）



### **5. 伴随式解码**

**定义**：对于接收字 x，计算 **s = xH**，称为 **伴随式**（syndrome）。

**单比特错误的伴随式**：
如果错误发生在第 i 位，即 `e = eᵢ = (0,...,0,1,0,...,0)`，那么：

$$
s = eH = \text{H 的第 i 行}
$$

**解码步骤**：
1. 计算伴随式 `s = xH`
2. 如果 `s = 0`，接受 x 为码字
3. 如果 `s ≠ 0` 且等于 H 的第 i 行，则翻转 x 的第 i 位来纠正
4. 如果 `s ≠ 0` 且不是 H 的任何一行，说明发生了多个错误



### **6. 单比特错误纠正的条件**

**定理**：设 H 是线性码 C 的校验矩阵。如果：
1. H 没有全零行
2. H 的所有行互不相同

那么 C 是 **1-错误纠正**的（可以纠正所有单比特错误）。

**原因**：每个单比特错误产生唯一的伴随式（对应 H 的不同行），因此可以唯一确定错误位置。


## **第三部分：示例分析**

### **示例 1：不能纠正所有单比特错误的码**

**校验矩阵**：

$$
H = \begin{pmatrix}
1 & 0 \\
1 & 1 \\
0 & 1 \\
1 & 0 \\
0 & 1
\end{pmatrix}
$$

问题：第1行和第4行相同。如果错误发生在第1位或第4位，伴随式都是 `(1,0)`，无法区分。

**对应的生成矩阵和码字**：

$$
G = \begin{pmatrix}
1 & 0 & 0 & 1 & 0 \\
0 & 1 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 1
\end{pmatrix}
$$

码字集合：`C = {00000, 00101, 01011, 01110, 10010, 10111, 11001, 11100}`

**最小重量**：`wt(C) = 2`，所以只能检测单比特错误，不能纠正所有单比特错误。



### **示例 2：可以纠正所有单比特错误的码**

**生成矩阵**：

$$
G = \begin{pmatrix}
1 & 0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 1 & 0 & 1
\end{pmatrix}
$$

**校验矩阵**：

$$
H = \begin{pmatrix}
1 & 1 & 0 \\
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{pmatrix}
$$

检查：所有行互不相同，没有全零行 ✓

**解码示例**：
收到 `x = 101010`：
```
计算伴随式 s = xH：
(1,0,1,0,1,0) × H = ?
逐列计算：
列1贡献：1×1 + 0×0 + 1×1 + 0×1 + 1×0 + 0×0 = 1 + 0 + 1 + 0 + 0 + 0 = 0 mod 2
列2贡献：1×1 + 0×1 + 1×0 + 0×0 + 1×1 + 0×0 = 1 + 0 + 0 + 0 + 1 + 0 = 0 mod 2
列3贡献：1×0 + 0×1 + 1×1 + 0×0 + 1×0 + 0×1 = 0 + 0 + 1 + 0 + 0 + 0 = 1 mod 2
所以 s = (0,0,1)
```
`s = (0,0,1)` 是 H 的第6行，说明第6位出错。

**纠正**：翻转第6位，`101010 → 101011`


## **第四部分：汉明码**

### **7. 汉明码的定义**

**定义**：汉明码是线性 `[2^m - 1, 2^m - m - 1]`-码，其校验矩阵 H 的行由 **Bᵐ** 中所有非零字组成。

**参数**：
- 码长：`n = 2^m - 1`
- 信息位：`k = 2^m - m - 1`
- 校验位：`n - k = m`

### **示例：m=3 的汉明码**
- `n = 2³ - 1 = 7`
- `k = 2³ - 3 - 1 = 4`
- 这是 **[7,4]-汉明码**

**系统形式的校验矩阵**：

$$
H = \begin{pmatrix}
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0 \\
1 & 1 & 1 \\
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{pmatrix}
$$

注意：前4行是 B³ 中重量≥2的所有非零字，后3行是单位矩阵。

**对应的生成矩阵**：

$$
G = \begin{pmatrix}
1 & 0 & 0 & 0 & 0 & 1 & 1 \\
0 & 1 & 0 & 0 & 1 & 0 & 1 \\
0 & 0 & 1 & 0 & 1 & 1 & 0 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{pmatrix} = [I₄ | A]
$$



### **8. 汉明码的性质**

1. **最小距离**：`d = 3`
   - 可以纠正 **1** 个错误
   - 可以检测 **2** 个错误

2. **完美码**：
   - 纠错半径 `r = 1`
   - 每个汉明球（半径1）包含 `1 + n = 1 + 7 = 8` 个字
   - 码字总数：`2⁴ = 16`
   - 总覆盖字数：`16 × 8 = 128 = 2⁷`
   - **恰好覆盖整个空间 B⁷**，没有重叠，没有遗漏

3. **伴随式解码特性**：
   - 任何非零伴随式都对应 H 的某一行
   - 任何单比特错误都能唯一纠正
   - 任何双比特错误都不能保证纠正（但有些可能偶然被纠正）

我们来深入探讨这两个关键问题：

### **问题一：为什么汉明码的最小距离为 3？**

#### **1. 从校验矩阵的角度证明**

**汉明码的校验矩阵 H**：
- H 是 `n × m` 矩阵，其中 `n = 2^m - 1`
- H 的 **每一列** 是 **Bᵐ** 中一个不同的非零二进制向量
- 因为 Bᵐ 中有 `2^m` 个向量，去掉全零向量，正好剩下 `2^m - 1 = n` 个不同的非零向量

**关键观察**：对于线性码，**最小距离 d = 最小非零码字的重量**

**证明 d ≥ 3**（分两步）：

**(1) 证明 d ≥ 2**（没有重量为 1 的码字）：
- 假设存在重量为 1 的码字 c，只有第 i 位为 1
- 那么 `cH = H 的第 i 行`（因为 c 只在第 i 位为 1）
- 但 c 是码字，必须满足 `cH = 0`
- 所以 `H 的第 i 行 = 0`，这与 H 没有全零行矛盾
- 因此**没有重量为 1 的码字**

**(2) 证明 d ≥ 3**（没有重量为 2 的码字）：
- 假设存在重量为 2 的码字 c，在第 i 位和第 j 位为 1（i ≠ j）
- 那么 `cH = H 的第 i 行 + H 的第 j 行`（模 2 加法）
- 因为 c 是码字，必须满足 `cH = 0`
- 所以 `H 的第 i 行 = H 的第 j 行`
- 但 H 的所有列（注意：是列，不是行）互不相同！
- 等价的逻辑：H 的列互不相同 ⇒ H 的行也互不相同（在系统形式下）
- 因此**没有重量为 2 的码字**

**(3) 证明 d = 3**（存在重量为 3 的码字）：
- 考虑 H 中任意两列相加：比如第 i 列 + 第 j 列
- 因为 H 的列包含所有非零 m 位向量，这两列的和（模 2）一定等于 H 的某个其他列，设为第 k 列
- 即：`Hᵢ + Hⱼ = Hₖ`（模 2）
- 构造向量 c，在第 i、j、k 位为 1，其余为 0
- 那么 `cH = Hᵢ + Hⱼ + Hₖ = (Hᵢ + Hⱼ) + Hₖ = Hₖ + Hₖ = 0`
- 所以 c 是重量为 3 的码字

**结论**：`d = 3`


#### **2. 几何直观理解**

在汉明码中：
- 任意两个不同码字至少相差 **3** 个比特
- 这是因为校验矩阵的列互不相同，使得任意两列的和不等于第三列，从而排除了重量为 2 的码字

**示例**：对于 m=3 的 [7,4]-汉明码
- 校验矩阵 H 的列是：`001, 010, 011, 100, 101, 110, 111`
- 任意两列的和都不等于某个第三列吗？检查：
  - `001 + 010 = 011`（这是第3列！）⇒ 所以第1、2、3列对应重量为3的码字
  - 但关键是要看是否会导致 `cH = 0`。确实，如果选择第1、2、3位为1，那么：
    `cH = 001 + 010 + 011 = 000`，所以是码字，重量为3


### **问题二：为什么汉明码是完美码？**

#### **1. 完美码的定义**

一个码称为**完美码**，如果存在整数 r ≥ 1，使得：
1. **球不相交**：以不同码字为中心、半径为 r 的汉明球互不相交
2. **全覆盖**：这些球的并集覆盖整个空间 **Bⁿ**

等价地：每个可能的接收字要么是码字，要么距离某个码字 ≤ r，且这种对应是唯一的。


#### **2. 汉明码的参数计算**

对于 **[n, k] 汉明码**：
- `n = 2^m - 1`
- `k = 2^m - m - 1`
- 最小距离 `d = 3`
- 纠错能力 `t = ⌊(d-1)/2⌋ = 1`

**计算球的大小**：
半径为 1 的汉明球包含的字数：

$$
|B₁(c)| = \binom{n}{0} + \binom{n}{1} = 1 + n = 1 + (2^m - 1) = 2^m
$$

**计算码字总数**：

$$
|C| = 2^k = 2^{2^m - m - 1}
$$

**计算所有球的总容量**：

$$
|C| \times |B₁(c)| = 2^{2^m - m - 1} \times 2^m = 2^{2^m - 1}
$$

**计算整个空间的大小**：

$$
|Bⁿ| = 2^n = 2^{2^m - 1}
$$

**完美！**：`|C| × |B₁(c)| = |Bⁿ|` ✓


#### **3. 几何解释：全覆盖且无重叠**

**为什么无重叠？**
- 因为最小距离 d = 3 > 2×1 = 2
- 所以半径为 1 的球中心距离至少为 3，球不会相交

**为什么全覆盖？**
- 整个空间有 `2^n` 个点
- 每个球有 `2^m` 个点
- 有 `2^{n-m} = 2^{2^m - 1 - m} = 2^k` 个球
- 乘积正好等于总点数

**形象比喻**：
- 想象一个 7 维超立方体（n=7时有 128 个顶点）
- 每个码字是一个顶点
- 以它为中心、半径为1的球包含：自身 + 7个相邻顶点（通过一条边相连）
- 共 8 个顶点
- 有 16 个这样的球（因为 k=4，码字数=16）
- 16 × 8 = 128，正好覆盖所有顶点
- 而且球之间没有公共顶点（因为最小距离3>2）


#### **4. 伴随式解码视角的完美性**

对于汉明码的校验矩阵 H（m×n）：
- H 有 `n = 2^m - 1` 列
- 这些列是 **Bᵐ** 中所有非零向量

**伴随式的可能值**：
- 伴随式 s 是 m 位向量，有 `2^m` 种可能
- 其中一种：`s = 0`（对应无错）
- 其余 `2^m - 1 = n` 种：正好对应 n 个单比特错误位置

**完美对应**：
```
伴随式空间（大小 2^m） ↔ 错误模式
    0          ↔ 无错
    第1列     ↔ 第1位错
    第2列     ↔ 第2位错
    ...
    第n列     ↔ 第n位错
```
**没有浪费**：每个可能的伴随式都对应一个可纠正的错误模式（单比特错或无错）。


### **综合示例：m=3 的 [7,4]-汉明码**

#### **参数验证**：
- `n = 2³ - 1 = 7`
- `k = 2³ - 3 - 1 = 4`
- `d = 3`
- `t = 1`

#### **球的大小**：

$$
V(7,1) = \binom{7}{0} + \binom{7}{1} = 1 + 7 = 8
$$

#### **码字数**：

$$
2^k = 2^4 = 16
$$

#### **总覆盖点数**：

$$
16 × 8 = 128
$$

#### **空间总点数**：

$$
2^7 = 128
$$

**完美！** 128 = 128 ✓


### **实际覆盖验证（部分）**：
码字 `0000000` 的球包含：
- `0000000`（自身）
- `1000000`, `0100000`, `0010000`, `0001000`, `0000100`, `0000010`, `0000001`（7个单比特错）

这些与任何其他码字的球都不重叠，因为任意两个码字至少差3位。


## **为什么完美性重要？**

### **理论意义**：
1. **最优性**：在给定 n 和 t 下，达到最大可能的码字数（最高编码效率）
2. **解码确定性**：每个接收字都有唯一最近码字（在半径 t 内）
3. **无解码失败**：不会出现"无法纠正"的情况（对于 ≤t 个错误）

### **实践意义**：
1. **解码简单**：可以构造完整的译码表
2. **效率最高**：没有浪费任何"空间"
3. **性能可预测**：错误纠正能力完全确定

### **局限**：
1. **只能纠正单比特错误**：t=1
2. **对突发错误不友好**：多个相邻比特错误会超出纠正能力
3. **扩展性有限**：参数由 m 决定，选择有限

## **实际应用意义**

1. **硬件实现简单**：伴随式计算只需模2加法和乘法
2. **解码效率高**：存储小译码表（将伴随式映射到错误位置）
3. **广泛应用**：汉明码用于内存纠错（ECC内存）、通信系统等
4. **扩展性强**：扩展汉明码、缩短汉明码等变体

**关键洞见**：校验矩阵不仅用于错误检测，通过伴随式解码，还能实现高效纠错，这是线性码理论的精髓之一。汉明码作为第一个发现的完美码，展示了如何在有限冗余下达到理论最优的纠错能力。
