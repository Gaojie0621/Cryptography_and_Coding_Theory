# **第13讲知识点详解：CRC算法与McEliece密码系统**

## **一、CRC算法（循环冗余校验）**

### **1. 背景与动机**
- **BSC模型局限**：之前假设的二进制对称信道模型中，错误是**独立随机**发生的
- **现实情况**：实际中错误常**成簇出现**（如CD划痕、突发干扰），称为**突发错误**

### **2. 核心思想**
CRC利用**多项式除法**来检测错误，特别擅长检测**突发错误**

### **3. 算法步骤**

#### **步骤1：选择生成多项式**
- 发送方和接收方事先约定一个**生成多项式** $g(x) \in \mathbb{Z}_2[x]$
- 设 $s = \deg g(x)$

#### **步骤2：处理消息**
- 消息 $m = m_0 m_1 \ldots m_{k-1} \in \mathbb{B}^k$
- 对应多项式： $m(x) = m_0 + m_1 x + \cdots + m_{k-1} x^{k-1}$

#### **步骤3：构造待编码多项式**
- 计算 $x^s m(x)$（相当于在消息后加 $s$ 个0）

#### **步骤4：计算校验位**
- 在 $\mathbb{Z}_2[x]$ 中做多项式除法：

$$
  x^s m(x) = q(x) g(x) + r(x)
$$

- 其中余式 $r(x)$ 的次数 $< s$
- 余式系数 $r_0, r_1, \ldots, r_{s-1}$ 就是**校验位**

#### **步骤5：生成码字**
- 码字： $c = r_0 r_1 \ldots r_{s-1} m_0 m_1 \ldots m_{k-1}$
- 对应多项式： $c(x) = x^s m(x) + r(x)$

### **4. 关键定理**
**定理**：在CRC算法中生成的码字多项式 $c(x)$ 能被 $g(x)$ 整除。

### **5. 检错能力**
- **保证检测**：所有长度 ≤ $s$ 的突发错误
- **可能检测**：部分长度 > $s$ 的突发错误
- **无法保证**：所有长度 > $s$ 的突发错误

### **6. 示例分析（讲义第8页）**
生成多项式： $g(x) = 1 + x + x^4$（ $s=4$ ）
消息： $m = 110$（ $m(x) = 1 + x$ ）
计算过程：
1. $x^4 m(x) = x^4 + x^5$
2. 除以 $g(x)$： $x^4 + x^5 = (1+x)(1+x+x^4) + (1+x^2)$
3. 余式： $r(x) = 1 + x^2$
4. 码字： $c = 1010110$

如果接收 $y = 1100010$（突发错误长度4）：
- 计算 $y(x)$ 除以 $g(x)$ 的余式不为零 → **错误被检测**

---

## **二、McEliece密码系统**

### **1. 核心安全原理**
基于**译码问题的困难性**：
- 对一般线性码，寻找给定向量的最近码字是**NP难问题**
- 但某些特殊构造的码（如Goppa码）有**高效译码算法**
- McEliece的巧妙想法：**伪装**一个容易译码的码，使其看起来像随机码

### **2. 密钥生成**

#### **私钥组成**：三元组 $(S, G, P)$
1. **G**：容易译码的线性 $[n,k]$ 码的生成矩阵（如Goppa码）
   - 能纠正 $t$ 个错误
   - 示例中：汉明码 $[7,4]$，$t=1$

2. **S**： $k \times k$ 可逆矩阵（"加扰器"）
   - 在模2下可逆： $\gcd(\det S, 2) = 1$

3. **P**： $n \times n$ 置换矩阵
   - 每行每列只有一个1
   - 性质： $P^{-1} = P^T$

#### **公钥计算**：

$$
G_1 = SGP \ (\text{mod } 2)
$$

- $G_1$ 是公开的
- 看起来像随机生成矩阵，难以译码

### **3. 加密过程**
明文： $x \in \mathbb{B}^k$
1. 用公钥编码： $xG_1$（得到 $C_1$ 码中的码字）
2. **故意添加错误**：选择随机向量 $e \in \mathbb{B}^n$，满足 $\text{wt}(e) = t$
3. 密文： $y = xG_1 + e$

**直观理解**：假装在传输码字 $xG_1$ 时发生了 $t$ 个错误

### **4. 解密过程（核心巧妙之处）**

#### **步骤1：消除置换影响**
计算： $y_1 = yP^{-1}$
因为 $y = xG_1 + e = xSGP + e$，所以：

$$
y_1 = (xSGP + e)P^{-1} = xSG + eP^{-1} = x_1 G + e_1
$$

其中：
- $x_1 = xS$
- $e_1 = eP^{-1}$（仍然是重量 $t$ 的向量，只是比特位置被置换）

**如果没有这一步会怎样？**

如果接收者尝试直接对 $y = xG_1 + e$ 译码：
1. $G_1$对应的码 $C_1$ 没有已知的高效译码算法
2. 需要解一般线性码的译码问题 → 计算困难
3. 解密失败

而通过 $yP^{-1}$ 变换后：
1. 回到原始码 $C$
2. $C$ 有高效译码算法（如Goppa码的Patterson算法）
3. 可以高效解密

$yP^{-1}$ 这一步是McEliece系统的**关键桥梁**：
- **数学上**：抵消了公钥中 $P$ 的影响
- **密码学上**：将困难问题转化为容易问题
- **工程上**：使得合法用户可以高效解密，而攻击者面对困难问题

这体现了**陷门函数**的思想：从易到难是简单的（乘 $P$ ），从难到易需要秘密信息（知道 $P^{-1}$ ）。

**核心等式总结**：

$$
\underbrace{yP^{-1}}_{\text{解密第一步}} = \underbrace{xSG}_{\text{原始码字}} + \underbrace{eP^{-1}}_{\text{置换错误}}
$$

左边的 $y$ 是困难问题，右边的 $xSG$ 是容易问题，中间的 $P^{-1}$ 是秘密钥匙。

#### **步骤2：利用原始码的译码能力**
现在 $y_1 = x_1 G + e_1$
- 这是原始码 $C$（由 $G$ 生成）中的码字加错误
- $C$ 是 $t$-纠错码，有高效译码算法
- 译码得到： $x_1 G$（最近码字），从而恢复 $x_1$

#### **步骤3：恢复明文**
计算： $x = x_1 S^{-1} \ (\text{mod } 2)$

### **5. 安全性分析**

#### **安全基础**：
1. **公钥 $G_1$** 看起来像随机矩阵
2. 攻击者面临问题：
   - 已知 $y = xG_1 + e$
   - 需要恢复 $x$ 和 $e$
   - 这等价于在看起来随机的码中译码 → **困难**

#### **密钥大小问题**：
- 使用建议的Goppa码： $n=1024, k=524, t=50$
- 公钥： $524 \times 1024$ 二进制矩阵 ≈ 67KB
- 私钥：包含三个矩阵，更大

#### **错误向量的巨大选择空间**：

$$
\binom{1024}{50} \approx 3.2 \times 10^{85}
$$

不同的错误模式，难以穷举

> "即使已知 $G_1$ 生成一个t-纠错码，并且知道 $y = xG_1 + e$ 中 $\text{wt}(e) = t$，但如果没有这个码的**代数结构信息**，我们仍然无法**高效地**从 $y$ 恢复 $x$。"

**关键点**：
- **知道纠错能力** ≠ **知道如何纠错**
- **理论存在性** ≠ **实际可计算性**

---

## **回到McEliece场景**

攻击者看到：

$$
y = xG_1 + e, \quad G_1 \text{ 公开}, \quad \text{wt}(e) = t
$$

**攻击者知道**：
1. $G_1$ 是 $k \times n$ 矩阵
2. 对应的码可以纠正 $t$ 个错误（从参数可推断）
3. $e$ 的重量是 $t$

**攻击者不知道**：
1. $G_1 = SGP$ 的分解
2. $G$ 是Goppa码的生成矩阵
3. Goppa多项式 $g(x)$
4. 置换 $P$

**因此攻击者**：
- 不能使用Patterson算法（需要 $g(x)$）
- 面对的是**看起来随机**的 $G_1$
- 只能尝试一般线性码译码方法 → **计算不可行**

### **6. 示例详解**

#### **参数**：
- 原始码：汉明 $[7,4]$ 码， $t=1$

$$
G = \begin{pmatrix} 
1&0&0&0&1&1&0 \\ 
0&1&0&0&1&0&1 \\ 
0&0&1&0&0&1&1 \\ 
0&0&0&1&1&1&1 
\end{pmatrix}
$$

- 加扰器 $S$、置换矩阵 $P$ 如讲义所示

#### **加密**：
明文： $x = 1101$
1. 计算 $xG_1 = 0110010$
2. 添加错误：$e = 0000100$（重量1）
3. 密文： $y = 0110010 + 0000100 = 0110110$

#### **解密**：
1. $y_1 = yP^{-1} = 1000111$
2. 对原始码译码（伴随式解码）：
   - 伴随式 $s = y_1 H = 001$
   - 对应第7列 → 翻转第7位 → $c = 1000110$
   - 系统部分：$x_1 = 1000$
3. $x = x_1 S^{-1} = 1101$

### **设计哲学：隐藏与恢复**

#### **McEliece的核心思想**：
> "把容易的问题伪装成困难的问题，但持有密钥的人知道如何去掉伪装"

具体来说：

1. **三重伪装**：
   - **G → SGP**：通过$S$和$P$把结构良好的$G$变成看起来随机的 $G_1$
   - 对攻击者： $G_1$ 看起来是随机矩阵，对应的码难以译码
   - 对合法接收者：知道 $S$ 和 $P$，可以"剥开"伪装

2. **为什么是$S$和$P$？**
   - **$S$（加扰器）**：改变码的**基**，但不改变码空间本身
   - **$P$（置换）**：改变码字的**坐标顺序**，但不改变距离性质
   - 两者都是**线性变换**，且**可逆**

3. **安全性保证**：
   - 攻击者看到：$y = xG_1 + e$ ，其中 $G_1$ 随机，$e$ 随机
   - 这是**一般线性码的译码问题** → **NP难**
   - 合法接收者：通过 $P^{-1}$ 回到易译码形式 


### **与其他密码系统的类比**

#### **类似RSA中的模幂运算**：
- RSA加密： $c = m^e \mod n$
- RSA解密： $m = c^d \mod n$ （使用私钥$d$）
- 这里的 $P^{-1}$ 类似于RSA解密中的模幂逆运算

#### **类似ElGamal中的指数运算**：
- ElGamal：用公钥 $g^a$ 加密，用私钥 $a$ 解密
- McEliece：用伪装的 $G_1$ 加密，用 $P^{-1}$ 和 $S^{-1}$ 解密


### **7. 教学意义**

#### **编码理论与密码学的融合**：
- **编码理论**：提供纠错能力
- **密码学**：利用"困难问题"保证安全

#### **"伪装"思想**：
- 将容易问题（特殊码的译码）**伪装**成困难问题（随机码的译码）
- 类似思想见于其他密码系统（如基于格的密码）

#### **后量子密码候选**：
- McEliece系统能抵抗量子计算机攻击
- 是NIST后量子密码标准化的重要候选

---

## **三、总结对比**

| **特性** | **CRC算法** | **McEliece系统** |
|---------|------------|----------------|
| **目的** | 错误检测 | 公钥加密 |
| **核心** | 多项式除法 | 编码+故意错误 |
| **安全基础** | 无（非密码） | 一般译码问题的困难性 |
| **数学工具** | $\mathbb{Z}_2[x]$ 多项式 | 线性代数、编码理论 |
| **应用场景** | 数据传输校验 | 安全通信 |

### **关键洞察**：
1. **CRC**：利用代数结构检测**突发错误**
2. **McEliece**：巧妙地将"容易译码"隐藏起来，使攻击者面对"困难译码"
3. **共同点**：都基于有限域上的代数运算，体现了编码理论在通信和安全中的双重作用

这两个主题展示了**代数编码理论**如何同时服务于：
- **可靠性**（CRC的错误检测）
- **安全性**（McEliece的加密）

体现了"数学是信息安全的基础"这一核心理念。